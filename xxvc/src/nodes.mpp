export module nodes;

import std;

import types;


export
enum class ExpressionType {
    eIdentifierExpression,
    eNumberExpression,
    eBinaryExpression,
};

export
enum class BinaryOperatorType {
    eAddition,
    eSubtraction,
    eMultiplication,
    eDivision,
};

export
enum class FunctionStatementType {
    eReturnStatement,
};

export
enum class ModuleStatementType {
    eFunctionDeclaration,
    eFunctionDefinition,
    eExternFunctionDeclaration,
};

export
class Node {
public:
private:
};

export
class IdentifierNode : public Node {
public:
    IdentifierNode(std::string name)
        : name_(std::move(name)) {}
    auto name() const -> std::string const& {
        return name_;
    }
private:
    std::string name_;
};

export
class NumberNode : public Node {
public:
    NumberNode(f64 number)
        : value_(number) {}
    auto value() const -> f64 {
        return value_;
    }
private:
    f64 value_;
};

export
class BinaryOperatorNode : public Node {
public:
    BinaryOperatorNode(BinaryOperatorType type)
        : type_(type) {}
    auto type() const -> BinaryOperatorType {
        return type_;
    }
private:
    BinaryOperatorType type_;
};

export
class ExpressionNode : public Node {
public:
    auto type() const -> ExpressionType {
        return type_;
    }
protected:
    ExpressionNode(ExpressionType type)
        : type_(type) {}
    ExpressionType type_;
};

export
class IdentifierExpressionNode : public ExpressionNode {
public:
    IdentifierExpressionNode(std::unique_ptr<IdentifierNode> identifier)
        : ExpressionNode(ExpressionType::eIdentifierExpression)
        , identifier_(std::move(identifier)) {}
    auto identifier() const -> std::unique_ptr<IdentifierNode> const& {
        return identifier_;
    }
private:
    std::unique_ptr<IdentifierNode> identifier_;
};

export
class NumberExpressionNode : public ExpressionNode {
public:
    NumberExpressionNode(std::unique_ptr<NumberNode> number)
        : ExpressionNode(ExpressionType::eNumberExpression)
        , number_(std::move(number)) {}
    auto number() const -> std::unique_ptr<NumberNode> const& {
        return number_;
    }
private:
    std::unique_ptr<NumberNode> number_;
};

export
class BinaryExpressionNode : public ExpressionNode {
public:
    BinaryExpressionNode(
        std::unique_ptr<BinaryOperatorNode> binaryOperator,
        std::unique_ptr<ExpressionNode> lhs,
        std::unique_ptr<ExpressionNode> rhs)
        : ExpressionNode(ExpressionType::eBinaryExpression)
        , binaryOperator_(std::move(binaryOperator))
        , lhs_(std::move(lhs))
        , rhs_(std::move(rhs)) {}
    auto binaryOperator() const -> std::unique_ptr<BinaryOperatorNode> const& {
        return binaryOperator_;
    }
    auto lhs() const -> std::unique_ptr<ExpressionNode> const& {
        return lhs_;
    }
    auto rhs() const -> std::unique_ptr<ExpressionNode> const& {
        return rhs_;
    }
private:
    std::unique_ptr<BinaryOperatorNode> binaryOperator_;
    std::unique_ptr<ExpressionNode> lhs_;
    std::unique_ptr<ExpressionNode> rhs_;
};

export
class FunctionPrototypeNode : public Node {
public:
    FunctionPrototypeNode(
        std::unique_ptr<IdentifierNode> identifier,
        std::vector<std::unique_ptr<IdentifierNode>> args)
        : identifier_(std::move(identifier))
        , args_(std::move(args)) {}
    auto identifier() const -> std::unique_ptr<IdentifierNode> const& {
        return identifier_;
    }
    auto args() const -> std::vector<std::unique_ptr<IdentifierNode>> const& {
        return args_;
    }
protected:
    std::unique_ptr<IdentifierNode> identifier_;
    std::vector<std::unique_ptr<IdentifierNode>> args_;
};

export
class FunctionStatementNode : public Node {
public:
    auto type() const -> FunctionStatementType {
        return type_;
    }
protected:
    FunctionStatementNode(FunctionStatementType type)
        : type_(type) {}
    FunctionStatementType type_;
};

export
class ReturnStatementNode : public FunctionStatementNode {
public:
    ReturnStatementNode(std::unique_ptr<ExpressionNode> expression)
        : FunctionStatementNode(FunctionStatementType::eReturnStatement)
        , expression_(std::move(expression)) {}
    auto expression() const -> std::unique_ptr<ExpressionNode> const& {
        return expression_;
    }
private:
    std::unique_ptr<ExpressionNode> expression_;
};

export
class ModuleStatementNode : public Node {
public:
    auto type() const -> ModuleStatementType {
        return type_;
    }
protected:
    ModuleStatementNode(ModuleStatementType type)
        : type_(type) {}
    ModuleStatementType type_;
};

export
class FunctionDeclarationNode : public ModuleStatementNode {
public:
    FunctionDeclarationNode(
        std::unique_ptr<FunctionPrototypeNode> prototype)
        : ModuleStatementNode(ModuleStatementType::eFunctionDeclaration)
        , prototype_(std::move(prototype)) {}
    auto prototype() const -> std::unique_ptr<FunctionPrototypeNode> const& {
        return prototype_;
    }
private:
    std::unique_ptr<FunctionPrototypeNode> prototype_;
};

export
class FunctionDefinitionNode : public ModuleStatementNode {
public:
    FunctionDefinitionNode(
        std::unique_ptr<FunctionPrototypeNode> prototype,
        std::vector<std::unique_ptr<FunctionStatementNode>> body)
        : ModuleStatementNode(ModuleStatementType::eFunctionDefinition)
        , prototype_(std::move(prototype))
        , body_(std::move(body)) {}
    auto prototype() const -> std::unique_ptr<FunctionPrototypeNode> const& {
        return prototype_;
    }
    auto body() const -> std::vector<std::unique_ptr<FunctionStatementNode>> const& {
        return body_;
    }
private:
    std::unique_ptr<FunctionPrototypeNode> prototype_;
    std::vector<std::unique_ptr<FunctionStatementNode>> body_;
};

export
class ExternFunctionDeclarationNode : public ModuleStatementNode {
public:
    ExternFunctionDeclarationNode(
        std::unique_ptr<FunctionPrototypeNode> prototype)
        : ModuleStatementNode(ModuleStatementType::eExternFunctionDeclaration)
        , prototype_(std::move(prototype)) {}
    auto prototype() const -> std::unique_ptr<FunctionPrototypeNode> const& {
        return prototype_;
    }
private:
    std::unique_ptr<FunctionPrototypeNode> prototype_;
};

export
class ModuleNode : public Node {
public:
    ModuleNode(std::vector<std::unique_ptr<ModuleStatementNode>> body)
        : body_(std::move(body)) {}
    auto body() const -> std::vector<std::unique_ptr<ModuleStatementNode>> const& {
        return body_;
    }
private:
    std::vector<std::unique_ptr<ModuleStatementNode>> body_;
};
