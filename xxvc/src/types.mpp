export module types;

import std;


export {

using f64 = double;
using i64 = std::int64_t;
using i32 = std::int32_t;
using u64 = std::uint64_t;
using u32 = std::uint32_t;
using b8 = bool;

}

export {

template <class T>
struct enable_self_destroy : std::false_type {};

}

template <class T>
concept SelfDestructable =
    requires (T* node) {
        { T::Destroy(node) } -> std::same_as<void>;
        requires enable_self_destroy<T>::value;
    };

template <class T>
requires SelfDestructable<T>
struct Destroy {
    auto operator() (T* node) -> void {
        T::Destroy(node);
    }
};

template <class T>
struct SelfDestructorImpl;

template <class T>
requires SelfDestructable<T>
struct SelfDestructorImpl<T> {
    using type = Destroy<T>;
};

template <class T>
requires (!SelfDestructable<T>)
struct SelfDestructorImpl<T> {
    using type = std::default_delete<T>;
};

export {

template <class T>
using SelfDestructor = SelfDestructorImpl<T>::type;

template <class T>
using uptr_t = std::unique_ptr<T, SelfDestructor<T>>;

template<class T, class Ptr>
auto uptr_cast(Ptr&& ptr) -> uptr_t<T> {
    return uptr_t<T>{ static_cast<T*>(ptr.release()) };
}

}
