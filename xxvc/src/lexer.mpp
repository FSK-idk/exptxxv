export module lexer;

import std;

import types;
import tokens;


export
class Lexer {
public:
    Lexer() {}

    auto tokenize(std::string const& program) -> std::vector<std::unique_ptr<Token>> {
        std::vector<std::unique_ptr<Token>> tokens;

        u64 size = program.size();

        u64 i = 0;
        while (i < size) {
            // spaces
            while (i < size && std::isspace(program[i])) ++i;
            if (i == size) break;

            // identifier or reserved
            if (std::isalpha(program[i])) {
                u64 j = i + 1; while (j < size && std::isalnum(program[j])) ++j;
                std::string_view name = std::string_view{ program.data() + i, program.data() + j };
                std::unique_ptr<Token> token;
                if      (name == "extern") { token = Token::Create(TokenType::eExtern); }
                else if (name == "return") { token = Token::Create(TokenType::eReturn); }
                else                       { token = IdentifierToken::Create(std::string(name)); }
                tokens.emplace_back(std::move(token));
                i = j; continue;
            }

            // number
            if (std::isdigit(program[i])) {
                // TODO: handle multiple dots e.g. '123.123.123'
                u64 j = i + 1; while (j < size && (std::isdigit(program[j]) || program[j] == '.')) ++j;
                f64 value; std::from_chars(program.data() + i, program.data() + j, value);
                tokens.emplace_back(NumberToken::Create(value));
                i = j; continue;
            }

            // special
            std::unique_ptr<Token> token;
            if      (program[i] == ':') { token = Token::Create(TokenType::eColon); }
            else if (program[i] == ';') { token = Token::Create(TokenType::eSemicolon); }
            else if (program[i] == ',') { token = Token::Create(TokenType::eComma); }
            else if (program[i] == '(') { token = Token::Create(TokenType::eLeftRoundBracket); }
            else if (program[i] == ')') { token = Token::Create(TokenType::eRightRoundBracket); }
            else if (program[i] == '{') { token = Token::Create(TokenType::eLeftCurlyBracket); }
            else if (program[i] == '}') { token = Token::Create(TokenType::eRightCurlyBracket); }
            else if (program[i] == '+') { token = Token::Create(TokenType::ePlus); }
            else if (program[i] == '-') { token = Token::Create(TokenType::eMinus); }
            else if (program[i] == '*') { token = Token::Create(TokenType::eAsterisk); }
            else if (program[i] == '/') { token = Token::Create(TokenType::eSlash); }
            else                        { token = Token::Create(TokenType::eUnknown); }
            tokens.emplace_back(std::move(token));

            ++i;
        }

        tokens.emplace_back(Token::Create(TokenType::eEof));

        return tokens;
    };
};
