module;

#include <cassert>

export module printer;

import std;

import types;
import nodes;


export
class Printer {
public:
    Printer() : step_(2), space_(-step_) {}

    auto print(ModuleNode* node) -> void {
        advance();
        indent(); std::println("module");
        indent(); std::println("-body");
        for (auto& statement : node->body) print(statement.get());
        retreat();
    }

    auto print(ModuleStatementNode* node) -> void {
        switch (node->type) {
        case ModuleStatementType::eFunctionDeclaration:
            return print(static_cast<FunctionDeclarationNode*>(node));
        case ModuleStatementType::eFunctionDefinition:
            return print(static_cast<FunctionDefinitionNode*>(node));
        case ModuleStatementType::eExternFunctionDeclaration:
            return print(static_cast<ExternFunctionDeclarationNode*>(node));
        default:
            assert(false && "add case");
        }
    }

    auto print(FunctionDeclarationNode* node) -> void {
        advance();
        indent(); std::println("function-declaration");
        indent(); std::println("-prototype");
        print(node->prototype.get());
        retreat();
    }

    auto print(FunctionDefinitionNode* node) -> void {
        advance();
        indent(); std::println("function-definition");
        indent(); std::println("-prototype");
        print(node->prototype.get());
        indent(); std::println("-body");
        for (auto& statement : node->body) print(statement.get());
        retreat();
    }

    auto print(ExternFunctionDeclarationNode* node) -> void {
        advance();
        indent(); std::println("extern-function-declaration");
        indent(); std::println("-prototype");
        print(node->prototype.get());
        retreat();
    }

    auto print(FunctionPrototypeNode* node) -> void {
        advance();
        indent(); std::println("function-prototype");
        indent(); std::println("-identifier");
        indent(); std::println("-name");
        print("{}", node->name);
        indent(); std::println("-args");
        for (auto& arg : node->args) print("{}", arg);
        retreat();
    }

    auto print(FunctionStatementNode* node) -> void {
        switch (node->type) {
        case FunctionStatementType::eVariableDeclaration:
            return print(static_cast<VariableDeclarationNode*>(node));
        case FunctionStatementType::eVariableDefinition:
            return print(static_cast<VariableDefinitionNode*>(node));
        case FunctionStatementType::eReturnStatement:
            return print(static_cast<ReturnStatementNode*>(node));
        default:
            assert(false && "add case");
        }
    }

    auto print(VariableDeclarationNode* node) -> void {
        advance();
        indent(); std::println("variable-declaration");
        indent(); std::println("-name");
        print("{}", node->name);
        retreat();
    }

    auto print(VariableDefinitionNode* node) -> void {
        advance();
        indent(); std::println("variable-declaration");
        indent(); std::println("-name");
        print("{}", node->name);
        indent(); std::println("-expression");
        print(node->expression.get());
        retreat();
    }

    auto print(ReturnStatementNode* node) -> void {
        advance();
        indent(); std::println("return-statement");
        indent(); std::println("-expression");
        print(node->expression.get());
        retreat();
    }

    auto print(ExpressionNode* node) -> void {
        switch (node->type) {
        case ExpressionType::eBinaryExpression:
            return print(static_cast<BinaryExpressionNode*>(node));
        case ExpressionType::eFunctionCallExpression:
            return print(static_cast<FunctionCallExpressionNode*>(node));
        case ExpressionType::eVariableExpression:
            return print(static_cast<VariableExpressionNode*>(node));
        case ExpressionType::eNumberExpression:
            return print(static_cast<NumberExpressionNode*>(node));
        case ExpressionType::eEmptyExpression:
            return print(static_cast<EmptyExpressionNode*>(node));
        default:
            assert(false && "add case");
        }
    }

    auto print(BinaryExpressionNode* node) -> void {
        advance();
        indent(); std::println("binary-expression");
        indent(); std::println("-binary-operator");
        print(node->binaryOperator.get());
        indent(); std::println("-lhs");
        print(node->lhs.get());
        indent(); std::println("-rhs");
        print(node->rhs.get());
        retreat();
    }

    auto print(FunctionCallExpressionNode* node) -> void {
        advance();
        indent(); std::println("function-call-expression");
        indent(); std::println("-name");
        print("{}", node->name);
        indent(); std::println("-args");
        for (auto& arg : node->args) print(arg.get());
        retreat();
    }

    auto print(VariableExpressionNode* node) -> void {
        advance();
        indent(); std::println("variable-expression");
        indent(); std::println("-name");
        print("{}", node->name);
        retreat();
    }

    auto print(NumberExpressionNode* node) -> void {
        advance();
        indent(); std::println("number-expression");
        indent(); std::println("-value");
        print("{}", node->value);
        retreat();
    }

    auto print(EmptyExpressionNode* node) -> void {
        advance();
        indent(); std::println("empty-expression");
        retreat();
    }

    auto print(BinaryOperatorNode* node) -> void {
        advance();
        indent(); std::println("binary-operator");
        indent(); std::println("-type");
        advance();
        switch (node->type) {
        case BinaryOperatorType::eAddition:
            indent(); std::println("addition"); break;
        case BinaryOperatorType::eSubtraction:
            indent(); std::println("subtraction"); break;
        case BinaryOperatorType::eMultiplication:
            indent(); std::println("multiplication"); break;
        case BinaryOperatorType::eDivision:
            indent(); std::println("division"); break;
        default:
            assert(false && "add case");
        }
        retreat();
        retreat();
    }

private:
    auto indent() -> void { std::print("{}", std::string(space_, ' ')); }
    auto advance() -> void { space_ += step_; }
    auto retreat() -> void { space_ -= step_; }
    template <class... Args>
    auto print(std::format_string<Args...> fmt, Args&&... args) -> void {
        advance();
        indent(); std::println(fmt, std::forward<Args>(args)...);
        retreat();
    }


private:
    u64 step_;
    u64 space_;
};
