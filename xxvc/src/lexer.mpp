module;

#include <cassert>

export module lexer;

import std;

import types;
import tokens;


enum class Result {
    eSuccess,
    eError,
    eInvalid,
};

export
class Lexer {
public:
    Lexer(std::string program) : program_(std::move(program)), iter_(program_.begin()) {}

    auto lex() -> b8 {
        while (!eof()) {
            while (!eof() && std::isspace(*current())) ++current();
            if (eof()) break;

            switch (lexIdentifierOrReserved()) {
            case Result::eSuccess: continue;
            case Result::eError: return false;
            case Result::eInvalid: break;
            }

            switch (lexNumber()) {
            case Result::eSuccess: continue;
            case Result::eError: return false;
            case Result::eInvalid: break;
            }

            switch (lexSpecial()) {
            case Result::eSuccess: continue;
            case Result::eError: return false;
            case Result::eInvalid: break;
            }

            assert(false && "last result shouldn't be invalid");
        }

        append<Token>(TokenType::eEof);

        return true;
    };

    auto tokens() -> std::vector<uptr_t<Token>>& { return tokens_; }

private:
    // identifier ::= alpha alphanum*
    auto lexIdentifierOrReserved() -> Result {
        if (!std::isalpha(*current())) return Result::eInvalid;

        auto start = current(); while (!eof() && std::isalnum(*current())) ++current();
        auto name = std::string_view{ start, current() };

        if (name == "extern") { return append<Token>(TokenType::eExtern); }
        if (name == "return") { return append<Token>(TokenType::eReturn); }
        if (name == "i64")    { return append<Token>(TokenType::eI64); }
        if (name == "i32")    { return append<Token>(TokenType::eI32); }
        if (name == "i16")    { return append<Token>(TokenType::eI16); }
        if (name == "u64")    { return append<Token>(TokenType::eU64); }
        if (name == "u32")    { return append<Token>(TokenType::eU32); }
        if (name == "u16")    { return append<Token>(TokenType::eU16); }
        if (name == "f64")    { return append<Token>(TokenType::eF64); }
        if (name == "f32")    { return append<Token>(TokenType::eF32); }

        return append<IdentifierToken>(std::string(name));
    }

    // integer ::= digit+ ( 'i' | 'i16' | 'i32' | 'i64' )?
    // unsigned ::= digit+ ( 'u' | 'u16' | 'u32' | 'u64' )
    // floating ::= digit+ '.' digit* ( 'f' | 'f32' | 'f64' )?
    // TODO: handle sign
    auto lexNumber() -> Result {
        if (!std::isdigit(*current())) return Result::eInvalid;

        auto start = current(); while (!eof() && std::isdigit(*current())) ++current();

        if (eof() || !std::string_view("iuf.").contains(*current())) {
            auto value = std::string_view{ start, current() };
            return append<IntegerToken>(std::string(value), BitSize::e64);
        }

        if (*current() == '.') {
            ++current(); while (!eof() && std::isdigit(*current())) ++current();
            auto value = std::string_view{ start, current() };

            if (eof() || *current() != 'f')
                return append<FloatingToken>(std::string(value), BitSize::e64);

            auto start = current()++; while (!eof() && std::isdigit(*current())) ++current();
            auto size = std::string_view{ start, current() };

            if (size == "f" || size == "f64") { return append<FloatingToken>(std::string(value), BitSize::e64); }
            if (size == "f32")                { return append<FloatingToken>(std::string(value), BitSize::e32); }
            return error("invalid floating suffix");
        }

        auto value = std::string_view{ start, current() };

        start = current()++; while (!eof() && std::isdigit(*current())) ++current();
        auto size = std::string_view{ start, current() };

        if (size == "i" || size == "i64") { return append<IntegerToken>(std::string(value), BitSize::e64); }
        if (size == "i32")                { return append<IntegerToken>(std::string(value), BitSize::e32); }
        if (size == "i16")                { return append<IntegerToken>(std::string(value), BitSize::e16); }
        if (size == "u" || size == "u64") { return append<UnsignedToken>(std::string(value), BitSize::e64); }
        if (size == "u32")                { return append<UnsignedToken>(std::string(value), BitSize::e32); }
        if (size == "u16")                { return append<UnsignedToken>(std::string(value), BitSize::e16); }
        if (size == "f" || size == "f64") { return append<FloatingToken>(std::string(value), BitSize::e64); }
        if (size == "f32")                { return append<FloatingToken>(std::string(value), BitSize::e32); }
        return error("invalid number suffix");
    }

    auto lexSpecial() -> Result {
        auto start = current()++;
        switch (*start) {
        case ':': return append<Token>(TokenType::eColon);
        case ';': return append<Token>(TokenType::eSemicolon);
        case ',': return append<Token>(TokenType::eComma);
        case '(': return append<Token>(TokenType::eLeftRoundBracket);
        case ')': return append<Token>(TokenType::eRightRoundBracket);
        case '{': return append<Token>(TokenType::eLeftCurlyBracket);
        case '}': return append<Token>(TokenType::eRightCurlyBracket);
        case '+': return append<Token>(TokenType::ePlus);
        case '-': return append<Token>(TokenType::eMinus);
        case '*': return append<Token>(TokenType::eAsterisk);
        case '/': return append<Token>(TokenType::eSlash);
        case '>': return append<Token>(TokenType::eGreater);
        default: return error("unknown symbol");
        }
    }

private:
    auto current() -> std::string::iterator& { return iter_; }
    auto eof() -> b8                         { return iter_ == program_.end(); }

    template <class T, class... Args>
    auto append(Args&&... args) -> Result { tokens_.emplace_back(uptr_cast<Token>(T::Create(std::forward<Args>(args)...))); return Result::eSuccess; }

    template <class... Args>
    auto error(std::format_string<Args...> fmt, Args&&... args) -> Result { std::println(fmt, std::forward<Args>(args)...); return Result::eError; }

private:
    std::string program_;
    std::string::iterator iter_;
    std::vector<uptr_t<Token>> tokens_;
};
