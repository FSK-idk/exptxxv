module;

#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Value.h>
#include <llvm/IR/GlobalValue.h>
#include <llvm/IR/Constant.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/Type.h>
#include <llvm/IR/Instructions.h>
#include <llvm/ADT/APFloat.h>
#include <llvm/ADT/APInt.h>
#include <llvm/Support/raw_os_ostream.h>

export module codegen;

import std;

import types;
import nodes;


export
class Codegen {
public:
    Codegen() {}

    auto codegen(ModuleNode* moduleNode) -> std::string {
        context_ = std::make_unique<llvm::LLVMContext>();
        module_ = std::make_unique<llvm::Module>("main", *context_);
        builder_ = std::make_unique<llvm::IRBuilder<>>(*context_);

        codegenModule(moduleNode);

        std::string output;
        llvm::raw_string_ostream os(output);
        module_->print(os, nullptr);

        builder_.reset();
        module_.reset();
        context_.reset();

        return output;
    }

private:
    auto codegenNumber(NumberNode* node) -> llvm::ConstantFP* {
        return llvm::ConstantFP::get(*context_, llvm::APFloat(node->value()));
    }

    auto codegenExpression(ExpressionNode* node) -> llvm::Value* {
        if (node->type() == ExpressionType::eBinaryExpression) {
            return codegenBinaryExpression(static_cast<BinaryExpressionNode*>(node));
        }
        else if (node->type() == ExpressionType::eIdentifierExpression) {
            return codegenIdenifierExpression(static_cast<IdentifierExpressionNode*>(node));
        }
        else if (node->type() == ExpressionType::eNumberExpression) {
            return codegenNumberExpression(static_cast<NumberExpressionNode*>(node));
        }
        return nullptr;
    }

    auto codegenBinaryExpression(BinaryExpressionNode* node) -> llvm::Value* {
        auto lhs = codegenExpression(node->lhs().get());
        auto rhs = codegenExpression(node->rhs().get());
        if (!lhs || !rhs) return nullptr;
        if (node->binaryOperator()->type() == BinaryOperatorType::eAddition) {
            return builder_->CreateFAdd(lhs, rhs, "addtmp");
        }
        if (node->binaryOperator()->type() == BinaryOperatorType::eSubtraction) {
            return builder_->CreateFSub(lhs, rhs, "subtmp");
        }
        if (node->binaryOperator()->type() == BinaryOperatorType::eMultiplication) {
            return builder_->CreateFMul(lhs, rhs, "multmp");
        }
        if (node->binaryOperator()->type() == BinaryOperatorType::eDivision) {
            return builder_->CreateFDiv(lhs, rhs, "divtmp");
        }
        return nullptr;
    }

    auto codegenIdenifierExpression(IdentifierExpressionNode* node) -> llvm::Value* {
        if (!variables_.contains(node->identifier()->name())) {
            std::println("unknown variable name");
            return nullptr;
        }
        llvm::AllocaInst* alloca = variables_[node->identifier()->name()];
        return builder_->CreateLoad(alloca->getAllocatedType(), alloca, node->identifier()->name());
    }

    auto codegenNumberExpression(NumberExpressionNode* node) -> llvm::Value* {
        return codegenNumber(node->number().get());
    }

    auto codegenFunctionPrototype(FunctionPrototypeNode* node) -> llvm::Function* {
        // TODO: remove after types are introduced
        if (node->identifier()->name() == "main") {
        std::vector<llvm::Type*> args(node->args().size(), llvm::Type::getDoubleTy(*context_));
            llvm::FunctionType* functionType = llvm::FunctionType::get(llvm::Type::getInt32Ty(*context_), args, false);
            llvm::Function* function = llvm::Function::Create(functionType, llvm::Function::ExternalLinkage, node->identifier()->name(), *module_);
            u32 i = 0; for (auto& arg : function->args()) arg.setName(node->args()[i++]->name());
            return function;
        }
        std::vector<llvm::Type*> args(node->args().size(), llvm::Type::getDoubleTy(*context_));
        llvm::FunctionType* functionType = llvm::FunctionType::get(llvm::Type::getDoubleTy(*context_), args, false);
        llvm::Function* function = llvm::Function::Create(functionType, llvm::Function::ExternalLinkage, node->identifier()->name(), *module_);
        u32 i = 0; for (auto& arg : function->args()) arg.setName(node->args()[i++]->name());
        return function;
    }

    auto codegenFunctionStatement(FunctionStatementNode* node) -> llvm::Value* {
        if (node->type() == FunctionStatementType::eReturnStatement) {
            return codegenReturnStatement(static_cast<ReturnStatementNode*>(node));
        }
        return nullptr;
    }

    auto codegenReturnStatement(ReturnStatementNode* node) -> llvm::Value* {
        // TODO: remove after types are introduced
        if (isMainFunction_) {
            auto expression = codegenExpression(node->expression().get());
            auto castedExpression = builder_->CreateCast(llvm::Instruction::CastOps::FPToSI, expression, llvm::Type::getInt32Ty(*context_));
            return builder_->CreateRet(castedExpression);
        }
        auto expression = codegenExpression(node->expression().get());
        return builder_->CreateRet(expression);
    }

    auto codegenModuleStatement(ModuleStatementNode* node) -> void {
        if      (node->type() == ModuleStatementType::eFunctionDeclaration) {
            codegenFunctionDeclaration(static_cast<FunctionDeclarationNode*>(node));
        }
        else if (node->type() == ModuleStatementType::eFunctionDefinition) {
            codegenFunctionDefinition(static_cast<FunctionDefinitionNode*>(node));
        }
        else if (node->type() == ModuleStatementType::eExternFunctionDeclaration) {
            codegenExternFunctionDeclaration(static_cast<ExternFunctionDeclarationNode*>(node));
        }
    }

    auto codegenFunctionDeclaration(FunctionDeclarationNode* node) -> void {
        // TODO: handle repeats
        auto function = codegenFunctionPrototype(node->prototype().get());
        functions_[node->prototype()->identifier()->name()] = function;
    }

    auto codegenFunctionDefinition(FunctionDefinitionNode* node) -> void {
        // TODO: handle repeats
        llvm::Function* function;
        if (functions_.contains(node->prototype()->identifier()->name())) {
            // TODO: check number of args in prototype
            function = functions_[node->prototype()->identifier()->name()];
        }
        else {
            function = codegenFunctionPrototype(node->prototype().get());
            functions_[node->prototype()->identifier()->name()] = function;
        }
        isMainFunction_ = node->prototype()->identifier()->name() == "main";
        llvm::BasicBlock* entryBlock = llvm::BasicBlock::Create(*context_, "entry", function);
        builder_->SetInsertPoint(entryBlock);
        for (auto& arg : function->args()) {
            llvm::IRBuilder<> builder(&function->getEntryBlock(), function->getEntryBlock().end());
            llvm::AllocaInst* argAlloca = builder.CreateAlloca(llvm::Type::getDoubleTy(*context_), nullptr, arg.getName());
            builder_->CreateStore(&arg, argAlloca);
        }
        for (auto& statement : node->body()) {
            codegenFunctionStatement(statement.get());
        }
    }

    auto codegenExternFunctionDeclaration(ExternFunctionDeclarationNode* node) -> void {
        // TODO: handle repeats
        llvm::Function* prototype;
        if (functions_.contains(node->prototype()->identifier()->name())) {
            // TODO: check number of args in prototype
            prototype = functions_[node->prototype()->identifier()->name()];
        }
        else {
            prototype = codegenFunctionPrototype(node->prototype().get());
            functions_[node->prototype()->identifier()->name()] = prototype;
        }
    }

    auto codegenModule(ModuleNode* node) -> void {
        for (auto& statement : node->body()) {
            codegenModuleStatement(statement.get());
        }
    }

private:
    std::unique_ptr<llvm::LLVMContext> context_;
    std::unique_ptr<llvm::Module> module_;
    std::unique_ptr<llvm::IRBuilder<>> builder_;

    std::map<std::string, llvm::Function*> functions_;
    std::map<std::string, llvm::AllocaInst*> variables_;
    bool isMainFunction_;
};
