export module parser;

import std;

import types;
import tokens;
import nodes;


// xxv grammar
//
// TODO: rewrite parser according to grammar
//
// module
//   ::= module-statement*
//
// module-statement
//   ::= function-declaration
//   ::= function-definition
//   ::= extern-function-declaration
// function-declaration
//   ::= !function-prototype ';'
// function-definition
//   ::= !function-prototype !function-statement-block ';'
// extern-function-declaration
//   ::= 'extern' !function-prototype ';'
//
// function-statement
//   ::= variable-declaration
//   ::= variable-definition
//   ::= return-statement
// variable-declaration
//   ::= !variable-prototype ';'
// variable-definition
//   ::= !variable-prototype !expression-block ';'
// return-statement
//   ::= 'return' expression ';'
//
// expression
//   ::= binary-expression
//   ::= !primary-expression
// binary-expression
//   ::= !non-empty-expression binary-operator !non-empty-expression
// function-call-expression
//   ::= identifier-token !non-empty-expression-list
// variable-expression
//   ::= identifier-token
// number-expression
//   ::= integer-token
//   ::= unsigned-token
//   ::= floating-token
// empty-expression
//   ::=
//
// binary-operator
//   ::= '+' | '-' | '*' | '/'
//
//
//
// !function-statement-block
//   ::= '{' function-statement* '}'
// !expression-block
//   ::= '{' expression '}'
//
// !non-empty-expression
//   ::= binary-expression
//   ::= !primary-expression - empty-expression
// !primary-expression
//   ::= '(' !non-empty-expression ')'
//   ::= function-call-expression
//   ::= variable-expression
//   ::= number-expression
//   ::= empty-expression
//
// !non-empty-expression-list
//   ::= '(' ( !non-empty-expression ( ',' !non-empty-expression )* ','? )? ')'
//
// !function-prototype
//   ::= identifier-token ':' !function-type
// !function-type
//   ::= !variable-prototype-list '->' !primary-type
//
// !variable-prototype-list
//   ::= '(' ( !variable-prototype ( ',' !variable-prototype )* ','? )? ')'
//
// !variable-prototype
//   ::= identifier-token ':' !primary-type
// !primary-type
//   ::= 'i64' | 'i32' | 'i16' | 'u64' | 'u32' | 'u16' | 'f64' | 'f32'


export
class Parser {
public:
    Parser(std::vector<uptr_t<Token>>& tokens)
        : tokens_(tokens), moduleNode_(nullptr) {}

    auto parse() -> b8 {
        tokenIndex_ = 0;
        moduleNode_ = parseModule();
        return moduleNode_ != nullptr;
    }

    auto moduleNode() const -> uptr_t<ModuleNode> const& { return moduleNode_; }

private:
    // module
    //   ::= module-statement*
    auto parseModule() -> uptr_t<ModuleNode> {
        std::vector<uptr_t<ModuleStatementNode>> body;
        while (true) {
            if (consume(TokenType::eEof)) break;

            auto statement = parseModuleStatement();
            if (!statement) return nullptr;
            body.emplace_back(std::move(statement));
        }

        return ModuleNode::Create(std::move(body));
    }

    // module-statement
    //   ::= function-declaration
    //   ::= function-definition
    //   ::= extern-function-declaration
    // function-declaration
    //   ::= function-prototype ';'
    // function-definition
    //   ::= function-prototype '{' function-statement* '}' ';'
    // extern-function-declaration
    //   ::= 'extern' function-prototype ';'
    auto parseModuleStatement() -> uptr_t<ModuleStatementNode> {
        b8 isExtern = false;
        if (consume(TokenType::eExtern)) isExtern = true;

        auto prototype = parseFunctionPrototype();
        if (!prototype) return nullptr;
        if (consume(TokenType::eSemicolon))
            return isExtern 
                ? uptr_cast<ModuleStatementNode>(ExternFunctionDeclarationNode::Create(std::move(prototype)))
                : uptr_cast<ModuleStatementNode>(FunctionDeclarationNode::Create(std::move(prototype)));

        if (!consume(TokenType::eLeftCurlyBracket))
            return error("expected left curly bracket");

        std::vector<uptr_t<FunctionStatementNode>> body;
        while (true) {
            if (consume(TokenType::eRightCurlyBracket)) break;

            auto statement = parseFunctionStatement();
            if (!statement) return nullptr;
            body.emplace_back(std::move(statement));
        }

        if (!consume(TokenType::eSemicolon))
            return error("expected semicolon");

        return uptr_cast<ModuleStatementNode>(FunctionDefinitionNode::Create(std::move(prototype), std::move(body)));
    }

    // function-prototype
    //   ::= identifier-token ':' '(' ( identifier-token ( ',' identifier-token )* ','? )? ')'
    auto parseFunctionPrototype() -> uptr_t<FunctionPrototypeNode> {
        auto identifier = consume<IdentifierToken>(TokenType::eIdentifier);
        if (!identifier)
            return error("expected identifier");

        if (!consume(TokenType::eColon))
            return error("expected colon");
        
        if (!consume(TokenType::eLeftRoundBracket))
            return error("expected left round bracket");

        std::vector<std::string> args;
        if (!consume(TokenType::eRightRoundBracket)) {
            auto identifier = consume<IdentifierToken>(TokenType::eIdentifier);
            if (!identifier)
                return error("expected identifier");
            args.emplace_back(std::move(identifier->name));

            while (true) {
                if (consume(TokenType::eRightRoundBracket)) break;

                if (!consume(TokenType::eComma))
                    return error("expected comma");

                if (consume(TokenType::eRightRoundBracket)) break;

                auto identifier = consume<IdentifierToken>(TokenType::eIdentifier);
                if (!identifier)
                    return error("expected identifier");
                args.emplace_back(std::move(identifier->name));
            }
        }

        return FunctionPrototypeNode::Create(std::move(identifier->name), std::move(args));
    }

    // function-statement
    //   ::= variable-declaration
    //   ::= variable-definition
    //   ::= return-statement
    // variable-declaration
    //   ::= identifier-token ';'
    // variable-definition
    //   ::= identifier-token ':' '{' expression '}' ';'
    // return-statement
    //   ::= 'return' expression ';'
    auto parseFunctionStatement() -> uptr_t<FunctionStatementNode> {
        if (auto identifier = consume<IdentifierToken>(TokenType::eIdentifier)) {
            if (consume(TokenType::eSemicolon))
                return uptr_cast<FunctionStatementNode>(VariableDeclarationNode::Create(std::move(identifier->name)));

            if (!consume(TokenType::eColon))
                return error("expected colon");

            if (!consume(TokenType::eLeftCurlyBracket))
                return error("expected left curly bracket");

            auto expression = parseExpression();
            if (!expression) return nullptr;

            if (!consume(TokenType::eRightCurlyBracket))
                return error("expected right curly bracket");

            if (!consume(TokenType::eSemicolon))
                return error("expected semicolon");

            return uptr_cast<FunctionStatementNode>(VariableDefinitionNode::Create(std::move(identifier->name), std::move(expression)));
        }
        else if (consume(TokenType::eReturn)) {
            auto expression = parseExpression();
            if (!expression) return nullptr;

            if (!consume(TokenType::eSemicolon))
                return error("expected semicolon");

            return uptr_cast<FunctionStatementNode>(ReturnStatementNode::Create(std::move(expression)));
        }

        return error("expected function statement");
    };

    // expression
    //   ::= binary-expression
    //   ::= primary-expression
    auto parseExpression() -> uptr_t<ExpressionNode> {
        auto expression = parsePrimaryExpression();
        if (!expression) return nullptr;

        if (expression->type == ExpressionType::eEmptyExpression) return expression;

        expression = parseBinaryExpressionRhs(0, std::move(expression));
        if (!expression) return nullptr;

        return expression;
    }

    // primary-expression
    //   ::= '(' expression ')'
    //   ::= function-call-expression
    //   ::= variable-expression
    //   ::= number-expression
    //   ::= empty-expression
    // function-call-expression
    //   ::= identifier-token ':' '(' ( expression - empty-expression ( ',' expression - empty-expression )* ','? )? ')'
    // variable-expression
    //   ::= identifier-token
    // number-expression
    //   ::= number-token
    // empty-expression
    //   ::=
    auto parsePrimaryExpression() -> uptr_t<ExpressionNode> {
        if (consume(TokenType::eLeftRoundBracket)) {
            auto expression = parseExpression();
            if (!expression) return nullptr;

            if (!consume(TokenType::eRightRoundBracket))
                return error("expected right round bracket");

            return expression;
        }
        if (auto identifier = consume<IdentifierToken>(TokenType::eIdentifier)) {
            if (consume(TokenType::eLeftRoundBracket)) {
                std::vector<uptr_t<ExpressionNode>> args;
                if (!consume(TokenType::eRightRoundBracket)) {
                    auto expression = parseExpression();
                    if (!expression) return nullptr;

                    if (expression->type == ExpressionType::eEmptyExpression)
                        return error("expected non-empty expression");

                    args.emplace_back(std::move(expression));
                    while (true) {
                        if (consume(TokenType::eRightRoundBracket)) break;

                        if (!consume(TokenType::eComma))
                            return error("expected comma");

                        if (consume(TokenType::eRightRoundBracket)) break;

                        auto expression = parseExpression();
                        if (!expression) return nullptr;

                        if (expression->type == ExpressionType::eEmptyExpression)
                            return error("expected non-empty expression");

                        args.emplace_back(std::move(expression));
                    }
                }

                return uptr_cast<ExpressionNode>(FunctionCallExpressionNode::Create(std::move(identifier->name), std::move(args)));
            }

            return uptr_cast<ExpressionNode>(VariableExpressionNode::Create(std::move(identifier->name)));
        }
        if (auto number = consume<FloatingToken>(TokenType::eFloating)) {
            return uptr_cast<ExpressionNode>(NumberExpressionNode::Create(std::stod(number->value)));
        }

        return uptr_cast<ExpressionNode>(EmptyExpressionNode::Create());
    }

    // binary-expression
    //   ::= ( primary-expression - empty-expression | binary-expression - empty-expression )
    //       binary-operator
    //       ( primary-expression - empty-expression | binary-expression - empty-expression )
    auto parseBinaryExpressionRhs(u64 currentPrecedence, uptr_t<ExpressionNode> lhs) -> uptr_t<ExpressionNode> {
        static std::map<BinaryOperatorType, i32> precedence = {
            { BinaryOperatorType::eAddition,       1 },
            { BinaryOperatorType::eSubtraction,    1 },
            { BinaryOperatorType::eMultiplication, 2 },
            { BinaryOperatorType::eDivision,       2 },
        };

        while (true) {
            auto binaryOperator = peekBinaryOperator();
            if (!binaryOperator) return lhs;
            if (currentPrecedence > precedence[binaryOperator->type]) return lhs;
            advance();

            auto rhs = parsePrimaryExpression();
            if (!rhs) return nullptr;

            if (rhs->type == ExpressionType::eEmptyExpression)
                return error("expected non-empty expression");

            auto nextBinaryOperator = peekBinaryOperator();
            if (nextBinaryOperator && precedence[binaryOperator->type] < precedence[nextBinaryOperator->type]) {
                rhs = parseBinaryExpressionRhs(precedence[nextBinaryOperator->type], std::move(rhs));
                if (!rhs) return nullptr;

                if (rhs->type == ExpressionType::eEmptyExpression)
                    return error("expected non-empty expression");

            }

            lhs = uptr_cast<ExpressionNode>(BinaryExpressionNode::Create(std::move(binaryOperator), std::move(lhs), std::move(rhs)));
        }
    }

    // binary-operator
    //   ::= '+' | '-' | '*' | '/'
    auto peekBinaryOperator() -> uptr_t<BinaryOperatorNode> {
        BinaryOperatorType type;
        switch (current()->type) {
            case TokenType::ePlus:     type = BinaryOperatorType::eAddition; break;
            case TokenType::eMinus:    type = BinaryOperatorType::eSubtraction; break;
            case TokenType::eAsterisk: type = BinaryOperatorType::eMultiplication; break;
            case TokenType::eSlash:    type = BinaryOperatorType::eDivision; break;
            default:
                return nullptr;
        }
        return BinaryOperatorNode::Create(type);
    }

private:
    auto current() -> Token* { return tokens_[tokenIndex_].get(); }
    auto advance() -> void { ++tokenIndex_; }
    template <class T = Token>
    auto consume(TokenType type) -> T* {
        if (current()->type == type) { return static_cast<T*>(tokens_[tokenIndex_++].get()); }
        return nullptr;
    }
    template <class... Args>
    auto error(std::format_string<Args...> fmt, Args&&... args) -> std::nullptr_t {
        std::println(fmt, std::forward<Args>(args)...);
        return nullptr;
    }

private:
    std::vector<uptr_t<Token>>& tokens_;
    u64 tokenIndex_;
    uptr_t<ModuleNode> moduleNode_;
};
