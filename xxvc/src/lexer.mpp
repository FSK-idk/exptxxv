export module lexer;

import std;

import types;
import tokens;


export
class Lexer {
public:
    Lexer(std::string program) : program_(std::move(program)) {}

    auto tokenize() -> void {
        u64 size = program_.size();

        u64 i = 0;
        while (i < size) {
            // spaces
            while (i < size && std::isspace(program_[i])) ++i;
            if (i == size) break;

            // identifier or reserved
            if (std::isalpha(program_[i])) {
                u64 j = i + 1; while (j < size && std::isalnum(program_[j])) ++j;
                std::string_view name = std::string_view{ program_.data() + i, program_.data() + j };
                uptr_t<Token> token;
                if      (name == "extern") { token = Token::Create(TokenType::eExtern); }
                else if (name == "return") { token = Token::Create(TokenType::eReturn); }
                else                       { token = uptr_cast<Token>(IdentifierToken::Create(std::string(name))); }
                tokens_.emplace_back(std::move(token));
                i = j; continue;
            }

            // number
            if (std::isdigit(program_[i])) {
                // TODO: handle multiple dots e.g. '123.123.123'
                u64 j = i + 1; while (j < size && (std::isdigit(program_[j]) || program_[j] == '.')) ++j;
                f64 value; std::from_chars(program_.data() + i, program_.data() + j, value);
                tokens_.emplace_back(uptr_cast<Token>(NumberToken::Create(value)));
                i = j; continue;
            }

            // special
            uptr_t<Token> token;
            if      (program_[i] == ':') { token = Token::Create(TokenType::eColon); }
            else if (program_[i] == ';') { token = Token::Create(TokenType::eSemicolon); }
            else if (program_[i] == ',') { token = Token::Create(TokenType::eComma); }
            else if (program_[i] == '(') { token = Token::Create(TokenType::eLeftRoundBracket); }
            else if (program_[i] == ')') { token = Token::Create(TokenType::eRightRoundBracket); }
            else if (program_[i] == '{') { token = Token::Create(TokenType::eLeftCurlyBracket); }
            else if (program_[i] == '}') { token = Token::Create(TokenType::eRightCurlyBracket); }
            else if (program_[i] == '+') { token = Token::Create(TokenType::ePlus); }
            else if (program_[i] == '-') { token = Token::Create(TokenType::eMinus); }
            else if (program_[i] == '*') { token = Token::Create(TokenType::eAsterisk); }
            else if (program_[i] == '/') { token = Token::Create(TokenType::eSlash); }
            else                         { token = Token::Create(TokenType::eUnknown); }
            tokens_.emplace_back(std::move(token));

            ++i;
        }

        tokens_.emplace_back(Token::Create(TokenType::eEof));
    };

    auto tokens() const -> std::vector<uptr_t<Token>> const& { return tokens_; }

private:
    std::string program_;
    std::vector<uptr_t<Token>> tokens_;
};
