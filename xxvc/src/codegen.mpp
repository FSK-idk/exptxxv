module;

#include <cassert>

#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Value.h>
#include <llvm/IR/GlobalValue.h>
#include <llvm/IR/Constant.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/Type.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/Verifier.h>
#include <llvm/ADT/APFloat.h>
#include <llvm/ADT/APInt.h>
#include <llvm/Support/raw_os_ostream.h>

export module codegen;

import std;

import types;
import nodes;


export
class Codegen {
public:
    Codegen(uptr_t<ModuleNode> const& node)
        : moduleNode_(node), isMainFunction_(false)
    {
        context_ = std::make_unique<llvm::LLVMContext>();
        module_ = std::make_unique<llvm::Module>("main", *context_);
        builder_ = std::make_unique<llvm::IRBuilder<>>(*context_);
    }

    auto codegenModule() -> b8 {
        if (!codegen(moduleNode_.get())) return false;
        return !llvm::verifyModule(*module_, &llvm::outs());
    }

    auto module() -> uptr_t<llvm::Module> const& { return module_; }

private:
    auto codegen(ModuleNode* node) -> llvm::Module* {
        for (auto& statement : node->body) {
            if (!codegen(statement.get())) return nullptr;
        }
        return module_.get();
    }

    auto codegen(ModuleStatementNode* node) -> llvm::Value* {
        switch (node->type) {
        case ModuleStatementType::eFunctionDeclaration:
            return codegen(static_cast<FunctionDeclarationNode*>(node));
        case ModuleStatementType::eFunctionDefinition:
            return codegen(static_cast<FunctionDefinitionNode*>(node));
        case ModuleStatementType::eExternFunctionDeclaration:
            return codegen(static_cast<ExternFunctionDeclarationNode*>(node));
        default:
            assert(false && "add case");
        }
    }

    auto codegen(FunctionDeclarationNode* node) -> llvm::Function* {
        if (functions_.contains(node->prototype->name)) {
            if (!std::ranges::equal(node->prototype->args, functions_[node->prototype->name]->args(), {}, {}, &llvm::Argument::getName))
                return error("function arguments do not match");

            return functions_[node->prototype->name];
        }

        auto function = createFunction(node->prototype->name, node->prototype->args);
        if (!function) return nullptr;
        functions_[node->prototype->name] = function;
        return function;
    }

    auto codegen(FunctionDefinitionNode* node) -> llvm::Function* {
        llvm::Function* function;
        if (functions_.contains(node->prototype->name)) {
            if (!std::ranges::equal(node->prototype->args, functions_[node->prototype->name]->args(), {}, {}, &llvm::Argument::getName))
                return error("function arguments do not match");

            function = functions_[node->prototype->name];
        }
        else {
            function = createFunction(node->prototype->name, node->prototype->args);
            if (!function) return nullptr;
            functions_[node->prototype->name] = function;
        }

        if (!function->isDeclaration())
            return error("function is already defined");

        isMainFunction_ = node->prototype->name == "main";

        llvm::BasicBlock* entryBlock = llvm::BasicBlock::Create(*context_, "entry", function);
        builder_->SetInsertPoint(entryBlock);
        variables_.clear();

        for (auto& arg : function->args()) {
            auto alloca = builder_->CreateAlloca(llvm::Type::getDoubleTy(*context_), nullptr, arg.getName());
            builder_->CreateStore(&arg, alloca);
            variables_[std::string(arg.getName())] = alloca;
        }

        for (auto& statement : node->body) {
            if (!codegen(statement.get())) return nullptr;
        };

        isMainFunction_ = false;
        return function;
    }

    auto codegen(ExternFunctionDeclarationNode* node) -> llvm::Function* {
        if (functions_.contains(node->prototype->name)) {
            if (!std::ranges::equal(node->prototype->args, functions_[node->prototype->name]->args(), {}, {}, &llvm::Argument::getName))
                return error("function arguments do not match");

            if (!functions_[node->prototype->name]->isDeclaration())
                return error("extern function shouldn't be definied");

            return functions_[node->prototype->name];
        }

        auto function = createFunction(node->prototype->name, node->prototype->args);
        if (!function) return nullptr;
        functions_[node->prototype->name] = function;
        return function;
    }

    auto codegen(FunctionStatementNode* node) -> llvm::Value* {
        switch (node->type) {
        case FunctionStatementType::eVariableDeclaration:
            return codegen(static_cast<VariableDeclarationNode*>(node));
        case FunctionStatementType::eVariableDefinition:
            return codegen(static_cast<VariableDefinitionNode*>(node));
        case FunctionStatementType::eReturnStatement:
            return codegen(static_cast<ReturnStatementNode*>(node));
        default:
            assert(false && "add case");
        }
    }

    auto codegen(VariableDeclarationNode* node) -> llvm::AllocaInst* {
        auto alloca = builder_->CreateAlloca(llvm::Type::getDoubleTy(*context_), nullptr, node->name);
        variables_[node->name] = alloca;
        return alloca;
    }

    auto codegen(VariableDefinitionNode* node) -> llvm::StoreInst* {
        llvm::AllocaInst* alloca;
        if (variables_.contains(node->name)) {
            alloca = variables_[node->name];
        }
        else {
            alloca = builder_->CreateAlloca(llvm::Type::getDoubleTy(*context_), nullptr, node->name);
            variables_[node->name] = alloca;
        }

        if (node->expression->type == ExpressionType::eEmptyExpression) {
            auto value = llvm::ConstantFP::get(*context_, llvm::APFloat(0.0));
            return builder_->CreateStore(value, alloca);
        }
        else {
            auto expression = codegen(node->expression.get());
            if (!expression) return nullptr;
            return builder_->CreateStore(expression, alloca);
        }
    }

    auto codegen(ReturnStatementNode* node) -> llvm::ReturnInst* {
        // TODO: remove after types are introduced
        if (isMainFunction_) {
            auto expression = codegen(node->expression.get());
            if (!expression) return nullptr;

            auto castedExpression = builder_->CreateCast(llvm::Instruction::CastOps::FPToSI, expression, llvm::Type::getInt32Ty(*context_));
            if (!castedExpression)
                return error("couldn't cast expression");

            return builder_->CreateRet(
                builder_->CreateCast(llvm::Instruction::CastOps::FPToSI, expression, llvm::Type::getInt32Ty(*context_)));
        }

        auto expression = codegen(node->expression.get());
        if (!expression) return nullptr;

        return builder_->CreateRet(expression);
    }

    auto codegen(ExpressionNode* node) -> llvm::Value* {
        switch (node->type) {
        case ExpressionType::eBinaryExpression:
            return codegen(static_cast<BinaryExpressionNode*>(node));
        case ExpressionType::eFunctionCallExpression:
            return codegen(static_cast<FunctionCallExpressionNode*>(node));
        case ExpressionType::eVariableExpression:
            return codegen(static_cast<VariableExpressionNode*>(node));
        case ExpressionType::eNumberExpression:
            return codegen(static_cast<NumberExpressionNode*>(node));
        case ExpressionType::eEmptyExpression:
            assert(false && "shouldn't be called");
        default:
            assert(false && "add case");
        }
    }

    auto codegen(BinaryExpressionNode* node) -> llvm::Value* {
        auto lhs = codegen(node->lhs.get());
        auto rhs = codegen(node->rhs.get());
        if (!lhs || !rhs) return nullptr;
        switch (node->binaryOperator->type) {
        case BinaryOperatorType::eAddition:
            return builder_->CreateFAdd(lhs, rhs, "addtmp");
        case BinaryOperatorType::eSubtraction:
            return builder_->CreateFSub(lhs, rhs, "subtmp");
        case BinaryOperatorType::eMultiplication:
            return builder_->CreateFMul(lhs, rhs, "multmp");
        case BinaryOperatorType::eDivision:
            return builder_->CreateFDiv(lhs, rhs, "divtmp");
        default:
            assert(false && "add case");
        }
    }

    auto codegen(FunctionCallExpressionNode* node) -> llvm::CallInst* {
        if (!functions_.contains(node->name))
            return error("unknown function");

        llvm::Function* fn = functions_[node->name];

        if (node->args.size() != fn->arg_size())
            return error("incorrect number of arguments");

        std::vector<llvm::Value*> argValues;
        for (u32 i = 0, e = node->args.size(); i != e; ++i) {
            auto arg = codegen(node->args[i].get());
            if (!arg) return nullptr;
            argValues.push_back(arg);
        }

        return builder_->CreateCall(fn, argValues, "calltmp");
    }

    auto codegen(VariableExpressionNode* node) -> llvm::LoadInst* {
        if (!variables_.contains(node->name))
            return error("unknown variable name");

        llvm::AllocaInst* alloca = variables_[node->name];
        return builder_->CreateLoad(alloca->getAllocatedType(), alloca, node->name);
    }

    auto codegen(NumberExpressionNode* node) -> llvm::ConstantFP* {
        return llvm::ConstantFP::get(*context_, llvm::APFloat(node->value));
    }

private:
    auto createFunction(std::string_view name, std::vector<std::string> const& args) -> llvm::Function* {
        // TODO: remove after types are introduced
        if (name == "main") {
            if (args.size() != 0)
                return error("function 'main' shouldn't have arguments");
            llvm::FunctionType* fnType = llvm::FunctionType::get(builder_->getInt32Ty(), {}, false);
            llvm::Function* fn = llvm::Function::Create(fnType, llvm::Function::LinkageTypes::ExternalLinkage, "main", *module_);
            return fn;
        }

        std::vector<llvm::Type*> fnArgs(args.size(), builder_->getDoubleTy());
        llvm::FunctionType* fnType = llvm::FunctionType::get(builder_->getDoubleTy(), fnArgs, false);
        llvm::Function* fn = llvm::Function::Create(fnType, llvm::Function::LinkageTypes::ExternalLinkage, name, *module_);
        u32 i = 0; for (auto& arg : fn->args()) arg.setName(args[i++]);
        return fn;
    }
    template <class... Args>
    auto error(std::format_string<Args...> fmt, Args&&... args) -> std::nullptr_t {
        std::println(fmt, std::forward<Args>(args)...);
        return nullptr;
    }

private:
    uptr_t<ModuleNode> const& moduleNode_;

    uptr_t<llvm::LLVMContext> context_;
    uptr_t<llvm::Module> module_;
    uptr_t<llvm::IRBuilder<>> builder_;

    std::map<std::string, llvm::Function*> functions_;
    std::map<std::string, llvm::AllocaInst*> variables_;

    b8 isMainFunction_;
};
