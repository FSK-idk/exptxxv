export module parser;

import std;

import types;
import tokens;
import nodes;


// xxv grammar
//
// module
//   ::= module-statement*
//
// module-statement
//   ::= function-declaration
//   ::= function-definition
//   ::= extern-function-declaration
// function-declaration
//   ::= function-prototype ';'
// function-definition
//   ::= function-prototype '{' function-statement* '}' ';'
// extern-function-declaration
//   ::= 'extern' function-prototype ';'
//
// function-prototype
//   ::= identifier ':' '(' ( identifier ( ',' identifier )* ','? )? ')'
//
// function-statement
//   ::= variable-declaration
//   ::= variable-definition
//   ::= return-statement
// variable-declaration
//   ::= identifier ';'
// variable-definition
//   ::= identifier ':' '{' expression '}' ';'
// return-statement
//   ::= 'return' expression ';'
//
// expression
//   ::= primary-expression
//   ::= binary-expression
// binary-expression
//   ::= expression binary-operator expression
// primary-expression
//   ::= '(' expression ')'
//   ::= variable-expression
//   ::= number-expression
// variable-expression
//   ::= identifier
// number-expression
//   ::= number
//
// identifier
//   ::= identifier-token
// number
//   ::= number-token
// binary-operator
//   ::= '+' | '-' | '*' | '/'


export
class Parser {
public:
    Parser() {}

    auto parse(std::vector<std::unique_ptr<Token>> tokens) -> std::unique_ptr<ModuleNode> {
        tokens_ = std::move(tokens);
        tokenIndex_ = 0;
        auto moduleNode = parseModule();
        tokens_.clear();
        return moduleNode;
    }

private:
    auto token() -> Token* {
        return tokens_[tokenIndex_].get();
    }

    auto advanceToken() -> void {
        ++tokenIndex_;
    }

    // module
    //   ::= module-statement*
    auto parseModule() -> std::unique_ptr<ModuleNode> {
        std::vector<std::unique_ptr<ModuleStatementNode>> body;
        while (true) {
            if (token()->type == TokenType::eEof) {
                advanceToken();
                break;
            }
            auto statement = parseModuleStatement();
            if (!statement) return nullptr;
            body.emplace_back(std::move(statement));
        }
        return ModuleNode::Create(std::move(body));
    }

    // module-statement
    //   ::= function-declaration
    //   ::= function-definition
    //   ::= extern-function-declaration
    // function-declaration
    //   ::= function-prototype ';'
    // function-definition
    //   ::= function-prototype '{' function-statement* '}' ';'
    // extern-function-declaration
    //   ::= 'extern' function-prototype ';'
    auto parseModuleStatement() -> std::unique_ptr<ModuleStatementNode> {
        b8 isExtern = false;
        if (token()->type == TokenType::eExtern) {
            isExtern = true;
            advanceToken();
        }
        auto prototype = parseFunctionPrototype();
        if (token()->type == TokenType::eSemicolon) {
            advanceToken();
            if (isExtern) {
                return ExternFunctionDeclarationNode::Create(std::move(prototype));
            }
            else {
                return FunctionDeclarationNode::Create(std::move(prototype));
            }
        }
        if (token()->type != TokenType::eLeftCurlyBracket) {
            std::println("expected left curly bracket");
            return nullptr;
        }
        advanceToken();
        std::vector<std::unique_ptr<FunctionStatementNode>> body;
        while (true) {
            if (token()->type == TokenType::eRightCurlyBracket) {
                advanceToken();
                break;
            }
            auto statement = parseFunctionStatement();
            if (!statement) return nullptr;
            body.emplace_back(std::move(statement));
        }
        if (token()->type != TokenType::eSemicolon) {
            std::println("expected semicolon");
            return nullptr;
        }
        advanceToken();
        return FunctionDefinitionNode::Create(std::move(prototype), std::move(body));
    }

    // function-prototype
    //   ::= identifier ':' '(' ( identifier ( ',' identifier )* ','? )? ')'
    auto parseFunctionPrototype() -> std::unique_ptr<FunctionPrototypeNode> {
        auto identifier = parseIdentifier();
        if (!identifier) return nullptr;
        if (token()->type != TokenType::eColon) {
            std::println("expected colon");
            return nullptr;
        }
        advanceToken();
        if (token()->type != TokenType::eLeftRoundBracket) {
            std::println("expected left round bracket");
            return nullptr;
        }
        advanceToken();
        std::vector<std::unique_ptr<IdentifierNode>> args;
        if (token()->type == TokenType::eRightRoundBracket) {
            advanceToken();
        }
        else {
            auto identifier = parseIdentifier();
            if (!identifier) return nullptr;
            args.emplace_back(std::move(identifier));
            while (true) {
                if (token()->type == TokenType::eRightRoundBracket) {
                    advanceToken();
                    break;
                }
                if (token()->type != TokenType::eComma) {
                    std::println("expected comma");
                    return nullptr;
                }
                advanceToken();
                if (token()->type == TokenType::eRightRoundBracket) {
                    advanceToken();
                    break;
                }
                auto identifier = parseIdentifier();
                if (!identifier) return nullptr;
                args.emplace_back(std::move(identifier));
            }
        }
        return FunctionPrototypeNode::Create(std::move(identifier), std::move(args));
    }

    // function-statement
    //   ::= variable-declaration
    //   ::= variable-definition
    //   ::= return-statement
    // variable-declaration
    //   ::= identifier ';'
    // variable-definition
    //   ::= identifier ':' '{' expression '}' ';'
    // return-statement
    //   ::= 'return' expression ';'
    auto parseFunctionStatement() -> std::unique_ptr<FunctionStatementNode> {
        if (token()->type == TokenType::eIdentifier) {
            auto identifier = parseIdentifier();
            if (!identifier) return nullptr;
            if (token()->type == TokenType::eSemicolon) {
                advanceToken();
                return VariableDeclarationNode::Create(std::move(identifier));
            }
            if (token()->type != TokenType::eColon) {
                std::println("exprected colon");
                return nullptr;
            }
            advanceToken();
            if (token()->type != TokenType::eLeftCurlyBracket) {
                std::println("exprected left curly bracket");
                return nullptr;
            }
            advanceToken();
            auto expression = parseExpression();
            if (!expression) return nullptr;
            if (token()->type != TokenType::eRightCurlyBracket) {
                std::println("exprected right curly bracket");
                return nullptr;
            }
            advanceToken();
            if (token()->type != TokenType::eSemicolon) {
                std::println("exprected semicolon");
                return nullptr;
            }
            advanceToken();
            return VariableDefinitionNode::Create(std::move(identifier), std::move(expression));
        }
        else if (token()->type == TokenType::eReturn) {
            advanceToken();
            auto expression = parseExpression();
            if (!expression) return nullptr;
            if (token()->type != TokenType::eSemicolon) {
                std::println("expected semicolon");
                return nullptr;
            }
            advanceToken();
            return ReturnStatementNode::Create(std::move(expression));
        }
        std::println("expected function statement");
        return nullptr;
    };

    // expression
    //   ::= primary-expression
    //   ::= binary-expression
    auto parseExpression() -> std::unique_ptr<ExpressionNode> {
        auto expression = parsePrimaryExpression();
        if (!expression) return nullptr;
        expression = parseBinaryExpressionRhs(0, std::move(expression));
        if (!expression) return nullptr;
        return expression;
    }

    // primary-expression
    //   ::= '(' expression ')'
    //   ::= variable-expression
    //   ::= number-expression
    // variable-expression
    //   ::= identifier
    // number-expression
    //   ::= number
    auto parsePrimaryExpression() -> std::unique_ptr<ExpressionNode> {
        if (token()->type == TokenType::eLeftRoundBracket) {
            advanceToken();
            auto expression = parseExpression();
            if (!expression) return nullptr;
            if (token()->type != TokenType::eRightRoundBracket) {
                std::println("expected right round bracket");
                return nullptr;
            }
            advanceToken();
            return expression;
        }
        if (token()->type == TokenType::eIdentifier) {
            auto identifier = parseIdentifier();
            if (!identifier) return nullptr;
            return VariableExpressionNode::Create(std::move(identifier));
        }
        if (token()->type == TokenType::eNumber) {
            auto number = parseNumber();
            if (!number) return nullptr;
            return NumberExpressionNode::Create(std::move(number));
        }
        std::println("expected expression");
        return nullptr;
    }

    // binary-expression
    //   ::= expression binary-operator expression
    auto parseBinaryExpressionRhs(u64 currentPrecedence, std::unique_ptr<ExpressionNode> lhs) -> std::unique_ptr<ExpressionNode> {
        static std::map<BinaryOperatorType, i32> precedence = {
            { BinaryOperatorType::eAddition,       1 },
            { BinaryOperatorType::eSubtraction,    1 },
            { BinaryOperatorType::eMultiplication, 2 },
            { BinaryOperatorType::eDivision,       2 },
        };

        while (true) {
            auto binaryOperator = peekBinaryOperator();
            if (!binaryOperator) return lhs;
            if (currentPrecedence > precedence[binaryOperator->type()]) return lhs;
            advanceToken();
            auto rhs = parsePrimaryExpression();
            if (!rhs) return nullptr;
            auto nextBinaryOperator = peekBinaryOperator();
            if (nextBinaryOperator && currentPrecedence < precedence[nextBinaryOperator->type()]) {
                rhs = parseBinaryExpressionRhs(precedence[nextBinaryOperator->type()], std::move(rhs));
                if (!rhs) return nullptr;
            }
            lhs = BinaryExpressionNode::Create(std::move(binaryOperator), std::move(lhs), std::move(rhs));
        }
    }

    // identifier
    //   ::= identifier-token
    auto parseIdentifier() -> std::unique_ptr<IdentifierNode> {
        if (token()->type != TokenType::eIdentifier) {
            std::println("expected identifier");
            return nullptr;
        }
        auto identifier = static_cast<IdentifierToken*>(token());
        advanceToken();
        return IdentifierNode::Create(std::move(identifier->name));
    }

    // number
    //   ::= number-token
    auto parseNumber() -> std::unique_ptr<NumberNode> {
        if (token()->type != TokenType::eNumber) {
            std::println("expected number");
            return nullptr;
        }
        auto number = static_cast<NumberToken*>(token());
        advanceToken();
        return NumberNode::Create(number->value);
    }

    // binary-operator
    //   ::= '+' | '-' | '*' | '/'
    auto peekBinaryOperator() -> std::unique_ptr<BinaryOperatorNode> {
        BinaryOperatorType type;
        if      (token()->type == TokenType::ePlus)     { type = BinaryOperatorType::eAddition; }
        else if (token()->type == TokenType::eMinus)    { type = BinaryOperatorType::eSubtraction; }
        else if (token()->type == TokenType::eAsterisk) { type = BinaryOperatorType::eMultiplication; }
        else if (token()->type == TokenType::eSlash)    { type = BinaryOperatorType::eDivision; }
        else                                            { return nullptr; }
        return BinaryOperatorNode::Create(type);
    }

private:
    std::vector<std::unique_ptr<Token>> tokens_;
    u64 tokenIndex_;
};
