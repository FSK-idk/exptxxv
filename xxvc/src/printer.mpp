module;

#include <cassert>

export module printer;

import std;

import types;
import tokens;
import nodes;


export
class Printer {
public:
    Printer() : step_(2), space_(-step_) {}

    auto print(ModuleNode* node) -> void {
        advance();
        indent(); std::println("module");
        indent(); std::println("-stmts");
        for (auto& stmt : node->stmts) print(stmt.get());
        retreat();
    }

    auto print(ModuleStatementNode* node) -> void {
        switch (node->type) {
        case ModuleStatementType::eFunctionDeclaration:
            return print(static_cast<FunctionDeclarationNode*>(node));
        case ModuleStatementType::eFunctionDefinition:
            return print(static_cast<FunctionDefinitionNode*>(node));
        case ModuleStatementType::eExternFunctionDeclaration:
            return print(static_cast<ExternFunctionDeclarationNode*>(node));
        default:
            assert(false && "add case");
        }
    }

    auto print(FunctionDeclarationNode* node) -> void {
        advance();
        indent(); std::println("function-declaration");
        indent(); std::println("-name");
        print("{}", node->name);
        indent(); std::println("-vars");
        for (auto& [name, type] : node->vars) {
            advance();
            indent(); std::println("-name");
            print("{}", name);
            indent(); std::println("-type");
            print(type);
            retreat();
        }
        indent(); std::println("-retType");
        print(node->retType);
        retreat();
    }

    auto print(FunctionDefinitionNode* node) -> void {
        advance();
        indent(); std::println("function-definition");
        indent(); std::println("-name");
        print("{}", node->name);
        indent(); std::println("-vars");
        for (auto& [name, type] : node->vars) {
            advance();
            indent(); std::println("-name");
            print("{}", name);
            indent(); std::println("-type");
            print(type);
            retreat();
        }
        indent(); std::println("-retType");
        print(node->retType);
        indent(); std::println("-stmts");
        for (auto& stmt: node->stmts) print(stmt.get());
        retreat();
    }

    auto print(ExternFunctionDeclarationNode* node) -> void {
        advance();
        indent(); std::println("extern-function-declaration");
        indent(); std::println("-name");
        print("{}", node->name);
        indent(); std::println("-vars");
        for (auto& [name, type] : node->vars) {
            advance();
            indent(); std::println("-name");
            print("{}", name);
            indent(); std::println("-type");
            print(type);
            retreat();
        }
        indent(); std::println("-retType");
        print(node->retType);
        retreat();
    }

    auto print(FunctionStatementNode* node) -> void {
        switch (node->type) {
        case FunctionStatementType::eVariableDeclaration:
            return print(static_cast<VariableDeclarationNode*>(node));
        case FunctionStatementType::eVariableDefinition:
            return print(static_cast<VariableDefinitionNode*>(node));
        case FunctionStatementType::eReturnStatement:
            return print(static_cast<ReturnStatementNode*>(node));
        default:
            assert(false && "add case");
        }
    }

    auto print(VariableDeclarationNode* node) -> void {
        advance();
        indent(); std::println("variable-declaration");
        indent(); std::println("-name");
        print("{}", node->name);
        indent(); std::println("-type");
        print(node->type);
        retreat();
    }

    auto print(VariableDefinitionNode* node) -> void {
        advance();
        indent(); std::println("variable-declaration");
        indent(); std::println("-name");
        print("{}", node->name);
        indent(); std::println("-type");
        print(node->type);
        indent(); std::println("-expr");
        print(node->expr.get());
        retreat();
    }

    auto print(ReturnStatementNode* node) -> void {
        advance();
        indent(); std::println("return-statement");
        indent(); std::println("-expr");
        print(node->expr.get());
        retreat();
    }

    auto print(ExpressionNode* node) -> void {
        switch (node->type) {
        case ExpressionType::eBinaryExpression:
            return print(static_cast<BinaryExpressionNode*>(node));
        case ExpressionType::eFunctionCallExpression:
            return print(static_cast<FunctionCallExpressionNode*>(node));
        case ExpressionType::eVariableExpression:
            return print(static_cast<VariableExpressionNode*>(node));
        case ExpressionType::eIntegerExpression:
            return print(static_cast<IntegerExpressionNode*>(node));
        case ExpressionType::eUnsignedExpression:
            return print(static_cast<UnsignedExpressionNode*>(node));
        case ExpressionType::eFloatingExpression:
            return print(static_cast<FloatingExpressionNode*>(node));
        case ExpressionType::eEmptyExpression:
            return print(static_cast<EmptyExpressionNode*>(node));
        default:
            assert(false && "add case");
        }
    }

    auto print(BinaryExpressionNode* node) -> void {
        advance();
        indent(); std::println("binary-expression");
        indent(); std::println("-opType");
        print(node->opType);
        indent(); std::println("-lhs");
        print(node->lhs.get());
        indent(); std::println("-rhs");
        print(node->rhs.get());
        retreat();
    }

    auto print(FunctionCallExpressionNode* node) -> void {
        advance();
        indent(); std::println("function-call-expression");
        indent(); std::println("-name");
        print("{}", node->name);
        indent(); std::println("-exprs");
        for (auto& arg : node->exprs) print(arg.get());
        retreat();
    }

    auto print(VariableExpressionNode* node) -> void {
        advance();
        indent(); std::println("variable-expression");
        indent(); std::println("-name");
        print("{}", node->name);
        retreat();
    }

    auto print(IntegerExpressionNode* node) -> void {
        advance();
        indent(); std::println("integer-expression");
        indent(); std::println("-value");
        print("{}", node->value);
        indent(); std::println("-size");
        print(node->size);
        retreat();
    }

    auto print(UnsignedExpressionNode* node) -> void {
        advance();
        indent(); std::println("unsigned-expression");
        indent(); std::println("-value");
        print("{}", node->value);
        indent(); std::println("-size");
        print(node->size);
        retreat();
    }

    auto print(FloatingExpressionNode* node) -> void {
        advance();
        indent(); std::println("floating-expression");
        indent(); std::println("-value");
        print("{}", node->value);
        indent(); std::println("-size");
        print(node->size);
        retreat();
    }

    auto print(EmptyExpressionNode* node) -> void {
        advance();
        indent(); std::println("empty-expression");
        retreat();
    }

private:
    auto print(PrimaryTypeType type) -> void {
        advance();
        indent();
        switch (type) {
        case PrimaryTypeType::eI64: std::println("i64"); break;
        case PrimaryTypeType::eI32: std::println("i32"); break;
        case PrimaryTypeType::eI16: std::println("i16"); break;
        case PrimaryTypeType::eU64: std::println("u64"); break;
        case PrimaryTypeType::eU32: std::println("u32"); break;
        case PrimaryTypeType::eU16: std::println("u16"); break;
        case PrimaryTypeType::eF64: std::println("f64"); break;
        case PrimaryTypeType::eF32: std::println("f32"); break;
        default:
            assert(false && "add case");
        }
        retreat();
    }

    auto print(BinaryOperatorType type) -> void {
        advance();
        indent();
        switch (type) {
        case BinaryOperatorType::eAddition:       std::println("addition"); break;
        case BinaryOperatorType::eSubtraction:    std::println("subtraction"); break;
        case BinaryOperatorType::eMultiplication: std::println("multiplication"); break;
        case BinaryOperatorType::eDivision:       std::println("division"); break;
        default:
            assert(false && "add case");
        }
        retreat();
    }

    auto print(BitSize size) -> void {
        advance();
        indent();
        switch (size) {
        case BitSize::e64: std::println("64"); break;
        case BitSize::e32: std::println("32"); break;
        case BitSize::e16: std::println("16"); break;
        default:
            assert(false && "add case");
        }
        retreat();
    }

    template <class... Args>
    auto print(std::format_string<Args...> fmt, Args&&... args) -> void {
        advance();
        indent(); std::println(fmt, std::forward<Args>(args)...);
        retreat();
    }

private:
    auto indent() -> void { std::print("{}", std::string(space_, ' ')); }
    auto advance() -> void { space_ += step_; }
    auto retreat() -> void { space_ -= step_; }

private:
    u64 step_;
    u64 space_;
};
