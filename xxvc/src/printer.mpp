export module printer;

import std;

import types;
import nodes;


export
class Printer {
public:
    Printer() : step_(2), space_(-step_) {}

    template <class T>
    auto print(T const& node) -> void;

    auto print(ModuleNode const& node) -> void {
        advance();
        indent(); std::println("module");
        indent(); std::println("-body");
        for (auto& statement : node.body()) print(*statement);
        retreat();
    }

    auto print(ModuleStatementNode const& node) -> void {
        switch (node.type()) {
        case ModuleStatementType::eFunctionDeclaration:
            print(static_cast<FunctionDeclarationNode const&>(node)); break;
        case ModuleStatementType::eFunctionDefinition:
            print(static_cast<FunctionDefinitionNode const&>(node)); break;
        case ModuleStatementType::eExternFunctionDeclaration:
            print(static_cast<ExternFunctionDeclarationNode const&>(node)); break;
        default:
            indent(); std::println("UNKNOWN NODE"); break;
        }
    }

    auto print(FunctionDeclarationNode const& node) -> void {
        advance();
        indent(); std::println("function-declaration");
        indent(); std::println("-prototype");
        print(*node.prototype());
        retreat();
    }

    auto print(FunctionDefinitionNode const& node) -> void {
        advance();
        indent(); std::println("function-definition");
        indent(); std::println("-prototype");
        print(*node.prototype());
        indent(); std::println("-body");
        for (auto& statement : node.body()) print(*statement);
        retreat();
    }

    auto print(ExternFunctionDeclarationNode const& node) -> void {
        advance();
        indent(); std::println("extern-function-declaration");
        indent(); std::println("-prototype");
        print(*node.prototype());
        retreat();
    }

    auto print(FunctionPrototypeNode const& node) -> void {
        advance();
        indent(); std::println("function-prototype");
        indent(); std::println("-identifier");
        print(*node.identifier());
        indent(); std::println("-args");
        for (auto& arg : node.args()) print(*arg);
        retreat();
    }

    auto print(FunctionStatementNode const& node) -> void {
        switch (node.type()) {
        case FunctionStatementType::eVariableDeclaration:
            print(static_cast<VariableDeclarationNode const&>(node)); break;
        case FunctionStatementType::eVariableDefinition:
            print(static_cast<VariableDefinitionNode const&>(node)); break;
        case FunctionStatementType::eReturnStatement:
            print(static_cast<ReturnStatementNode const&>(node)); break;
        default:
            indent(); std::println("UNKNOWN NODE"); break;
        }
    }

    auto print(VariableDeclarationNode const& node) -> void {
        advance();
        indent(); std::println("variable-declaration");
        indent(); std::println("-identifier");
        print(*node.identifier());
        retreat();
    }

    auto print(VariableDefinitionNode const& node) -> void {
        advance();
        indent(); std::println("variable-declaration");
        indent(); std::println("-identifier");
        print(*node.identifier());
        indent(); std::println("-expression");
        print(*node.expression());
        retreat();
    }

    auto print(ReturnStatementNode const& node) -> void {
        advance();
        indent(); std::println("return-statement");
        indent(); std::println("-expression");
        print(*node.expression());
        retreat();
    }

    auto print(ExpressionNode const& node) -> void {
        switch (node.type()) {
        case ExpressionType::eBinaryExpression:
            print(static_cast<BinaryExpressionNode const&>(node)); break;
        case ExpressionType::eVariableExpression:
            print(static_cast<VariableExpressionNode const&>(node)); break;
        case ExpressionType::eNumberExpression:
            print(static_cast<NumberExpressionNode const&>(node)); break;
        case ExpressionType::eEmptyExpression:
            print(static_cast<EmptyExpressionNode const&>(node)); break;
        default:
            indent(); std::println("UNKNOWN NODE"); break;
        }
    }

    auto print(BinaryExpressionNode const& node) -> void {
        advance();
        indent(); std::println("binary-expression");
        indent(); std::println("-binary-operator");
        print(*node.binaryOperator());
        indent(); std::println("-lhs");
        print(*node.lhs());
        indent(); std::println("-rhs");
        print(*node.rhs());
        retreat();
    }

    auto print(VariableExpressionNode const& node) -> void {
        advance();
        indent(); std::println("variable-expression");
        indent(); std::println("-identifier");
        print(*node.identifier());
        retreat();
    }

    auto print(NumberExpressionNode const& node) -> void {
        advance();
        indent(); std::println("number-expression");
        indent(); std::println("-number");
        print(*node.number());
        retreat();
    }

    auto print(EmptyExpressionNode const& node) -> void {
        advance();
        indent(); std::println("empty-expression");
        retreat();
    }

    auto print(IdentifierNode const& node) -> void {
        advance();
        indent(); std::println("identifier");
        indent(); std::println("-name");
        indent(); std::println("  {}", node.name());
        retreat();
    }

    auto print(NumberNode const& node) -> void {
        advance();
        indent(); std::println("number");
        indent(); std::println("-value");
        advance();
        indent(); std::println("{}", node.value());
        retreat();
        retreat();
    }

    auto print(BinaryOperatorNode const& node) -> void {
        advance();
        indent(); std::println("binary-operator");
        indent(); std::println("-type");
        advance();
        switch (node.type()) {
        case BinaryOperatorType::eAddition:
            indent(); std::println("addition"); break;
        case BinaryOperatorType::eSubtraction:
            indent(); std::println("subtraction"); break;
        case BinaryOperatorType::eMultiplication:
            indent(); std::println("multiplication"); break;
        case BinaryOperatorType::eDivision:
            indent(); std::println("division"); break;
        default:
            indent(); std::println("UNKNOWN TYPE"); break;
        }
        retreat();
        retreat();
    }

private:
    auto indent() -> void { std::print("{}", std::string(space_, ' ')); }
    auto advance() -> void { space_ += step_; }
    auto retreat() -> void { space_ -= step_; }

private:
    u64 step_;
    u64 space_;
};
