export module types;

import std;


export {

using f64 = double;
using i64 = std::int64_t;
using i32 = std::int32_t;
using u64 = std::uint64_t;
using u32 = std::uint32_t;
using b8 = bool;

}

export {

template <class T>
struct enable_self_destroy : std::false_type {};

}

template <class T>
concept SelfDestructable =
    requires (T* node) {
        { T::Destroy(node) } -> std::same_as<void>;
        requires enable_self_destroy<T>::value;
    };

template <class T>
requires SelfDestructable<T>
struct Destroy {
    auto operator() (T* node) -> void {
        T::Destroy(node);
    }
};

template <class T>
struct SelfDestructorImpl;

template <class T>
requires SelfDestructable<T>
struct SelfDestructorImpl<T> {
    using type = Destroy<T>;
};

template <class T>
requires (!SelfDestructable<T>)
struct SelfDestructorImpl<T> {
    using type = std::default_delete<T>;
};

export {

template <class T>
using SelfDestructor = SelfDestructorImpl<T>::type;

template <class T>
using uptr_t = std::unique_ptr<T, SelfDestructor<T>>;

template <class T>
auto make_uptr(T&& t) -> uptr_t<T> {
    return uptr_t<T> {
        new T{ std::forward<T>(t) }
    };
}

template<class T, class D>
auto uptr_cast(uptr_t<D> ptr) -> uptr_t<T> {
    return uptr_t<T>{ static_cast<T*>(ptr.release()) };
}

template <template <class...> class C, class T>
class uptr_iterator {
public:
    using iterator_category = std::forward_iterator_tag;
    using difference_type   = std::ptrdiff_t;
    using value_type        = uptr_t<T>::element_type;
    using pointer           = uptr_t<T>::element_type*;
    using reference         = uptr_t<T>&;

    explicit uptr_iterator(C<uptr_t<T>>::iterator iter) : iter_(iter) {}

    reference operator*() const { return *iter_; }
    pointer operator->() { return iter_->get(); }
    uptr_iterator& operator++() { ++iter_; return *this; }  
    uptr_iterator operator++(int) { return uptr_iterator(iter_++); }
    friend b8 operator== (uptr_iterator const& a, uptr_iterator const& b) { return a.iter_ == b.iter_; };

private:
    C<uptr_t<T>>::iterator iter_;
};

}
